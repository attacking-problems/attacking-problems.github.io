[#lambdas-and-streams]
:imagesdir: chapters/lambdas-and-streams/images
:programsdir: chapters/lambdas-and-streams/programs
== Lambdas and Streams

[quote, Harry S. Truman]
____
Actions are the seeds of fate. Deeds grow into destiny.
____

=== Problem: Cryptography tools

_Cryptography_, from Greek roots meaning "secret writing," is the science of
scrambling and unscrambling messages so that only the intended recipients can
read them. Forms of cryptography have been used since ancient times, often in
a military context. In fact, making and breaking codes played an important role
in World War II. Now, modern cryptography is an essential tool to protect
personal data as it's sent over the Internet. Without strong cryptography,
credit card data, social security numbers, and other private information would
be stolen by criminals even more than they are already.

The act of scrambling a message so that it's no longer readable is called
_encryption_. The act of unscrambling an encrypted message so that it's readable
again is called _decryption_. A normal, unencrypted message is often called a
_plaintext_. An encrypted message is called a _ciphertext_. Many encryption
algorithms use a _key_, an extra piece of information like a secret phrase,
that's needed when doing the encryption and decryption.

What's the right approach for designing a program that can encrypt and decrypt
data? It's tempting to pick your favorite encryption and build the program
around that. Unfortunately, cryptographers are always working to find ways to
defeat any given algorithm. Over the years, they might discover weaknesses that
could allow attackers to unscramble a ciphertext, even without the secret key.
For that reason, a good framework for using cryptography should allow an
arbitrary algorithm to be used instead of forcing a user to keep using an
algorithm that has known security vulnerabilities.

For that reason, we want to design a framework that can accept any (or at least 
a huge range of) encryption and decryption algorithms. We want the framework to
take care of iterating through all the characters in a message and send each
character off to the appropriate algorithm to be transformed from plaintext to
ciphertext or vice versa.

Most modern encryption algorithms like AES encrypt bytes (or blocks of bytes),
but our solution will use simpler algorithms that are designed to encrypt only
the capital letters A through Z from the Latin alphabet. The examples we'll use
are the Caesar cipher, the affine cipher, and the Vigenère cipher, all classical
substitution ciphers that have been used in the past but are now considered
unsecure. With a little additional work, it's possible to expand our solution to
secure algorithms as well.

==== Caesar cipher

Substitution ciphers are encryption systems that change each letter in a
plaintext to a different one. The Caesar cipher, used by Julius Caesar himself,
is perhaps the simplest possible substitution cipher. In it, the key is a number
1 through 25. This number says how many places later in the alphabet the
encrypted version of a letter is than the unencrypted version. For example, if
the key is 7, then each plaintext letter should be replaced with the letter that
comes seven steps later in the alphabet, wrapping around as needed. In this
case, the letter A is changed to H, the letter K is changed to R, and the letter
V wraps around the end of the alphabet to change into C.

Here's a table showing all the unencrypted alphabet in the first row and the
encrypted versions of each letter in the second.

[.center%autowidth,cols="<.^s,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^",]
|=======================================================================

|Plaintext |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
|Ciphertext |H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|A|B|C|D|E|F|G
|=======================================================================

Thus, the message `"NOW IS THE WINTER OF OUR DISCONTENT"` would be encrypted to
`"UVD PZ AOL DPUALY VM VBY KPZJVUALUA"`.



==== Affine cipher

==== Vigenère cipher




=== Concepts: Passing and storing methods


=== Syntax: Lambda expressions


==== Functional interfaces

==== Type inference


.Custom sorting
====

====


=== Advanced: Streams



.Filtering a stream
====

====


=== Solution: Cryptography tools

=== Concurrency: Lambdas and streams


=== Exercises
*Conceptual Problems*

. Exercise 1

*Programming Practice*

. Exercise 2


*Experiments*

. Exercise 3