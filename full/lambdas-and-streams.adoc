[#lambdas-and-streams]
:imagesdir: chapters/lambdas-and-streams/images
:programsdir: chapters/lambdas-and-streams/programs
== Lambdas and Streams

[quote, Harry S. Truman]
____
Actions are the seeds of fate. Deeds grow into destiny.
____

=== Problem: Cryptography tools

_Cryptography_, from Greek roots meaning "secret writing," is the science of
scrambling and unscrambling messages so that only the intended recipients can
read them. Forms of cryptography have been used since ancient times, often in
a military context. In fact, making and breaking codes played an important role
in World War II. Now, modern cryptography is an essential tool to protect
personal data as it's sent over the Internet. Without strong cryptography,
credit card data, social security numbers, and other private information would
be stolen by criminals even more than they are already.

The act of scrambling a message so that it's no longer readable is called
_encryption_. The act of unscrambling an encrypted message so that it's readable
again is called _decryption_. A normal, unencrypted message is often called a
_plaintext_. An encrypted message is called a _ciphertext_. Many encryption
algorithms use a _key_, an extra piece of information like a secret phrase,
that's needed when doing the encryption and decryption.

What's the right approach for designing a program that can encrypt and decrypt
data? It's tempting to pick your favorite encryption and build the program
around that. Unfortunately, cryptographers are always working to find ways to
defeat any given algorithm. Over the years, they might discover weaknesses that
could allow attackers to unscramble a ciphertext, even without the secret key.
For that reason, a good framework for using cryptography should allow an
arbitrary algorithm to be used instead of forcing a user to keep using an
algorithm that has known security vulnerabilities.

For that reason, we want to design a framework that can accept any (or at least 
a huge range of) encryption and decryption algorithms. We want the framework to
take care of iterating through all the characters in a message and send each
character off to the appropriate algorithm to be transformed from plaintext to
ciphertext or vice versa.

Most modern encryption algorithms like AES encrypt bytes (or blocks of bytes),
but our solution will use simpler algorithms that are designed to encrypt only
the capital letters A through Z from the Latin alphabet. The examples we'll use
are the Caesar cipher, the affine cipher, and the Vigenère cipher, all classical
substitution ciphers that have been used in the past but are now considered
unsecure. With a little additional work, it's possible to expand our solution to
secure algorithms as well.

==== Caesar cipher

Substitution ciphers are encryption systems that change each letter in a
plaintext to a different one. The Caesar cipher, used by Julius Caesar himself,
is perhaps the simplest possible substitution cipher. In it, the key is a number
1 through 25. This number says how many places later in the alphabet the
encrypted version of a letter is than the unencrypted version. For example, if
the key is 7, then each plaintext letter should be replaced with the letter that
comes seven steps later in the alphabet, wrapping around as needed. In this
case, the letter A is changed to H, the letter K is changed to R, and the letter
V wraps around the end of the alphabet to change into C.

The Caesar cipher is also called a shift cipher since we're shifting all the
letters of the alphabet over by a fixed amount.

Here's a table showing all the unencrypted alphabet in the first row and the
encrypted versions of each letter in the second, when the key is 7.

[.center%autowidth,cols="<.^s,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^",]
|=======================================================================

|Plaintext |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
|Ciphertext |H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|A|B|C|D|E|F|G
|=======================================================================

Thus, the message `"NOW IS THE WINTER OF OUR DISCONTENT"` would be encrypted to
`"UVD PZ AOL DPUALY VM VBY KPZJVUALUA"`. To decrypt a message, we move each
letter in the message back by the shift.


==== Affine cipher

The affine cipher takes the Caesar cipher a step further. Instead of simply
adding a value to each letter to encrypt it, we multiply each letter by a number
and then add a value to it. Thus, the key has two parts, a scalar _a_ and a
shift _b_.

In order to make the math simpler, we first convert the letters A through Z into
the numbers 0 through 25. That's the number that we multiply by _a_ before
adding _b_. Finally, we take the result modulus 26 so that any value larger than
25 maps back to the range 0 to 25. Written in mathematical notation, the
encrypted version of a letter whose value is _x_ is (_a_ · _x_ + _b_) mod 26.

Note that the scalar _a_ *must* be _coprime_ with the size of your alphabet, in
our case 26. Otherwise, different letters in the plaintext will map to the same
letters in the ciphertext, making it impossible to decrypt the original message.
Two numbers are coprime if they share none of the same prime factors. For an
alphabet with length 26, that means that _a_ can only have the values 1, 3, 5,
7, 9, 11, 15, 17, 19, 21, 23, or 25. When _a_ = 1, the affine cipher is simply
a Caesar cipher.

Here's a table showing all the unencrypted alphabet in the first row and the
encrypted versions of each letter in the second, with a value of 5 for _a_ and
8 for _b_.

[.center%autowidth,cols="<.^s,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^,^.^",]
|=======================================================================

|Plaintext |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
|Ciphertext |I|N|S|X|C|H|M|R|W|B|G|L|Q|V|A|F|K|P|U|Z|E|J|O|T|Y|D
|=======================================================================

With this cipher, the message `"NOW IS THE WINTER OF OUR DISCONTENT"` would now
be encrypted to `"VAO WU ZRC OWVZCP AH AEP XWUSAVZCVZ"`. To decrypt a message,
we first subtract the value _b_ from each letter and then multiply by the
multiplicative inverse of _a_ modulus 26. Finding the multiplicative inverse of
a number can be done with brute force or some number theory, and we'll discuss
doing so in <<Solution: Cryptography tools>>.

==== Vigenère cipher




=== Concepts: Passing and storing methods


=== Syntax: Lambda expressions


==== Functional interfaces

==== Type inference


.Custom sorting
====

====


=== Advanced: Streams



.Filtering a stream
====

====


=== Solution: Cryptography tools

=== Concurrency: Lambdas and streams


=== Exercises
*Conceptual Problems*

. Exercise 1

*Programming Practice*

// index of coincidence for Vigenere cipher?
// automatically break a Caesar cipher?

. Exercise 2


*Experiments*

. Exercise 3