[#ch15-gui]
:imagesdir: chapters/15-gui/images
:programsdir: chapters/15-gui/programs
== Constructing Graphical User Interfaces

[quote, Napoleon Bonaparte]
____
A good sketch is better than a long speech.
____

=== Problem: Math applet

An _applet_ is a graphical Java program that runs inside of a special
environment, usually a web browser. The beauty of an applet is that
anyone with a Java-enabled web browser can run the program without any
special knowledge or computer skills. Most users don't even realize they
are running a program.

[[mathTutorAppletFigure]]
.The `MathTutorApplet` as seen through the Google Chrome browser. (a) Initial applet. (b) Selecting an operation to practice. (c) After some practice.
image::mathTutorAppletFigure.svg[scaledwidth=100%,pdfwidth=100%,width=100%]

Let's write an applet that will allow young math students to practice
their arithmetic. Specifically, we are interested in addition,
subtraction, multiplication, and division with small, positive integers.
For this program, we will consider addition and subtraction basic and
multiplication and division advanced. Our applet should allow the user
to select a check box in a menu setting the mode to advanced or basic.
The user should then be able to select one of the four operations from
another menu. Once the operation is selected, the applet should generate
a random problem testing that operation. The problem should be displayed
as a label on the applet with a text field to one side. The user should
be able to enter an answer in the text field and hit a button to submit
it. The applet should check the answer and display the updated number of
correct and incorrect answers.

<<mathTutorAppletFigure>> shows the final applet in three
different states. The screen to the left appears when the applet is
first initialized, and the Submit button is disabled until a problem is generated.

=== Concepts: Graphical user interfaces

The applet shown above with its menus, labels, buttons, and other
interactive components is called a graphical user interface, or GUI. A
GUI is a means of communication between a computer program and a
(usually human) user. (Although it is possible for some programs such as
scripts to interact with a GUI, most program to program communication is
done in other ways.) While communication through input and output on the
console is one way to communicate with a program, GUIs offer a
user-friendly alternative that has become extremely commonplace. In
fact, GUIs are so common that many people have never used anything else
to interact with programs and may not even suspect that other kinds of
interaction are possible.

This chapter will teach you how to write programs with GUIs. Although
GUIs can make input and output easier for the user, the programmer has
to shoulder the burden of arranging the layout and appearance of the GUI
and making it function properly. <<ch07-gui-basics#ch07-gui-basics>> introduced a way to make simple GUIs, but those GUIs came
in preset flavors designed for displaying a message, getting a range of
responses in the form of buttons, or reading a short piece of text as
input. In this chapter we will explore ways to make GUIs of arbitrary
complexity with no limitations on the size or shape of the GUI or the
components it contains.

A typical GUI consists of a _frame_ (also known as a window) on which
are displayed one or more components (known as widgets), such as panels,
buttons, and text boxes. _Panels_ are used to organize the contents
within the frame. A frame contains at least one panel, but additional
ones can be added. Each panel can also contain widgets: buttons, labels,
text boxes, and even other panels. Using code to create a GUI with all
the widgets laid out exactly where you want them is half the work of
making a GUI-driven program in Java.

Some components like labels are read-only to the user. They display
information such as status messages. Other components are more dynamic
in the sense that the user can use these to give input to the program.
Such components are associated with events. Handling events inside of a
program is the other half of writing a GUI program in Java. Layout is
concerned with appearance, but event handling is concerned with
functionality.

There are IDEs such as NetBeans have graphical tools that automatically
generate the GUI code for you. We focus on how to write this code
yourself because doing so gives you more control and helps you
understand Java GUIs better.

==== Swing and AWT

Most of the components you will use to create GUIs are defined in
classes that belong to the Java Swing library. This library contains
many interfaces and classes. Several components of the Swing library are
built upon another library known as the Abstract Window Toolkit that is
commonly referred to as AWT. In earlier chapters, you have seen, and
probably used, one class in the Swing library, the `JOptionPane` class.

The AWT is an older library which provides direct access to the OS
widgets. Thus, an AWT `Button` object in Microsoft Windows creates a
Windows button. Swing, however, draws its own button. AWT GUIs look
exactly like other GUIs from the same OS. Swing GUIs can be configured
to look similar using _look and feel_ settings, or developers can choose
to use a default Java look and feel that will look almost the same
across all platforms.

We will discuss Swing widgets such as `JButton` and `JTextField`. Swing
components usually have a `J` at the beginning of their names to
distinguish them from similar AWT components. (The AWT contains `Button`
and `TextField`. If you see examples from other sources using widgets
that do not start with `J`, they are probably using AWT.) Although Swing
is built on top of the older AWT library, it is not a good idea to mix
Swing and AWT components in a single GUI, though it is possible.

The Swing library is far too large for us to cover in its entirety.
Instead, our goal is to show you how to construct GUIs using some of the
most common Java widgets. Once you have grasped the material in this
chapter, you will be able to read and understand how to use many other
interesting Swing components, as well as other Java libraries for
constructing GUIs. Since a frame is the basis for most windowed GUIs, we
will begin by showing you how to create a frame and display it on the
screen.

=== Syntax: GUIs in Java

==== Creating a frame

A frame is the Java terminology for a window. Except when programming an
applet, GUI components in Java will usually be found on a frame. In
Swing, a frame is an object whose type is derived from the `JFrame`
class. Here is a line of code that creates a `JFrame` object.

[source,java]
----
JFrame soundCheck = new JFrame("Sound Check");
----

The above statement declares and creates a `JFrame` object named
`soundCheck`. The title of the frame is "`Sound Check`" and is given as
an argument to the `JFrame` constructor. Although calling the
constructor creates the frame, you need to make it visible for it to
show up on the screen.

[source,java]
----
soundCheck.setVisible(true);
----

The `setVisible()` method causes the `soundCheck` frame to be visible on
the screen as a window. You can specify its size as in the following
code.

[source,java]
----
soundCheck.setSize(300,200);
----

The `setSize()` method sets the width and height of the frame specified
in pixels. In the above example, the width of `soundCheck` is set to 300
pixels and its height to 200 pixels. The window created by the above
code is resizable. You could use the following code if you do not want
the user to be able to resize the window.

[source,java]
----
soundCheck.setResizable(false);
----

Your entire GUI will often be a frame you create and the components
inside that frame. You might want your application to end when you close
the frame by clicking on the close button towards the top. The actual
location of this button depends on the operating system and the look and
feel managers you are using. Regardless, the following statement can be
used to set the behavior of the application when you close the frame
window.

[source,java]
----
soundCheck.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
----

.Pitfall: Closing frames
[WARNING]
====

Some books and online tutorials suggest setting `JFrame.EXIT_ON_CLOSE`
as the default close operation for a `JFrame` instead of
`JFrame.DISPOSE_ON_CLOSE`. In our opinion, this option should never be
used.

Using `JFrame.EXIT_ON_CLOSE` is equivalent to calling
`System.exit(0)`, which shuts down the JVM. In a single-threaded
application, the difference between disposing and exiting is small.
However, in a multi-threaded application, shutting down the JVM means
killing off all the other threads, no matter what task they are
performing. In general, `System.exit()` should never be called,
whether the program has a GUI or not.

By using `JFrame.DISPOSE_ON_CLOSE`, the frame releases all the
resources it has been using and terminates any threads it uses to redraw
itself and check for events. If there are no other threads running, the
application will then shut down.

It is still necessary to select *some* default closing operation. By
default, the operation is set to `JFrame.HIDE_ON_CLOSE`, which hides
the frame but does not end its threads. Unfortunately, if the frame is
the only way you have of interacting with your application, you can no
longer use it! At that point, you may have to use a process or task
manager to shut down the JVM by hand.

====


[[emptyFrameExample]]
.Empty frame
====

<<EmptyFrameProgram>> creates and displays an empty frame with
the title "`Sound Check.`" Note that we have used the `import` statement
to let the compiler know that we are using the Swing library. The first
line inside the `main()` method declares and creates a `JFrame` object
and assigns a title to it. The following line sets its size. The third
line sets the default close operation and the following line makes the
frame visible. The frame so created is shown in
<<emptyFrameFigure>>. Note that the frame is resizable.

.Creates an empty frame.
[source, java, linenums]
[[EmptyFrameProgram]]
----
include::{programsdir}/EmptyFrame.java[]
----

[[emptyFrameFigure]]
[.text-center]
.An empty frame titled "`Sound Check.`"
image::emptyFrameFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]


You may resize the frame at any point in the program even after the
frame has been created and made visible. The initial size may or may not
be set prior to making the frame visible. Similarly, the frame title can
be set, and reset, at any point in the program.

====

==== Widgets

A widget is a component of a GUI. Java provides a large variety of
widgets including panels, buttons, text boxes, check boxes, and menus.
While laying out a GUI, one or more of the widgets are created and then
placed on a frame. A widget is declared and created like any other
object.

[source,java]
----
Widget w = new Widget(arguments);
----

Here we use class `Widget` to represent some Java widget class like
`JButton` or , and we use reference `w` to represent the name of a
widget like `startButton`. Arguments supplied while constructing a
widget allow you to set attributes such as its icon, color, size, or
text to display. A widget can be added to a frame and removed when not
needed. Its attributes can also be changed after creation.

Although widgets can be added directly to a frame, it is often
convenient to lay out a GUI by placing panels on a frame and then
placing widgets on the panels. Each panel can hold zero or more widgets.
A panel is also referred to as a _container_ object. Next we show you
how to create a panel, populate it with widgets, place it on a frame,
and display the completed frame.

A panel is an instance of the `JPanel` class and can be created as
follows.

[source,java]
----
JPanel soundPanel = new JPanel();
----

This statement creates a panel named `soundPanel`. Thus far, the panel
is empty. Let's create two buttons and add these to `soundPanel`.

[source,java]
----
JButton chirp = new JButton("Chirp");
JButton bark = new JButton("Bark");
soundPanel.add(chirp);
soundPanel.add(bark);
----

The first two lines above create two buttons named `chirp` and `bark`.
These buttons are labeled using the `String` values `"Chirp"` and
`"Bark"`, but their labels could be any `String` values. The last two
statements add the two buttons one by one to the `soundPanel`. Then we
add the panel to a frame object.

[source,java]
----
soundCheck.add(soundPanel);
----

This statement adds the `soundPanel` to `soundCheck` frame that we
created in <<emptyFrameExample>>.

Another useful widget is `JTextField`. It creates a text field that can
be used by a program for both input and output of `String` data.

[source,java]
----
JTextField message = new JTextField("This is not a pipe.");
----

This statement creates an object named `message` as an instance of the
`JTextField` class. When displayed, it will show the message "`This is
not a pipe.`" The user can replace this text by typing, but we will need
to talk about event handling before we can read the text and act on it
from within a program. The following example combines various concepts
and widgets already introduced into one program.

.GUI with buttons and text field
====

We will now write an application with a GUI that contains three buttons
labeled "`Chirp,`" "`Bark,`" and "`Exit.`" In addition it contains a
text field that initially displays the text, "`Listen to nature!`"

In this example the buttons are only for display. You can click each
one, but the program will not do anything useful. Similarly, the text
field will not be changed by the program after it is initialized. In the
next subsection we add actions to each button and make the program more
useful.

.Creates a frame with a panel containing three buttons.
[source, java, linenums]
[[FrameWithPanelProgram]]
----
include::{programsdir}/FrameWithPanel.java[]
----
<1> We first create a frame named `soundCheck`.
<2> Then a panel named `soundPanel`.
<3> Next, we create three buttons named `chirp`, `bark`, and `exit` and a text field named `message`.
<4> We add the buttons and the text field to `soundPanel`.
<5> Add `soundPanel` to `soundCheck`.
<6> After setting the size and the closing operation, the frame is made
visible.

The final GUI is shown in <<frameWithAPanelFigure>>.
Note that the same GUI may look different on different platforms. Later
we will see how to add multiple panels to a frame.

[[frameWithAPanelFigure]]
[.text-center]
.GUI consisting of a frame, a panel, three buttons, and a text field.
image::frameWithAPanelFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]
====

****
<<multipleAddsExercise>>
****

==== Adding actions to widgets

Many widgets in Java can be used to cause an action. For example, a user
could click a button labeled "`Chirp,`" causing the program to play a
bird chirp sound. Clicking a button generates an _event_. In Java, an
event is processed by one or more _listeners_. Java provides various
types of listeners, some of which are introduced here and a few others
in <<Applets>>. Next we show you how to handle action
events generated by a few different kinds of widgets.

===== The `ActionListener` interface

Java provides an `ActionListener` interface. This interface has a single
method named `actionPerformed()`. This method takes an `ActionEvent` as
input and performs a suitable action based on the event. A `JButton`
object generates `ActionEvent` when it is pressed. Any class that
implements the `ActionListener` interface can be registered as an action
listener on a `JButton` or any other widget that generates an
`ActionEvent`.

As discussed in <<ch10-interfaces#ch10-interfaces>>, an interface is a set of
method signatures. If you implement an interface, you promise to have
all of the methods in the interface. If a class implements
`ActionListener`, it's saying that it knows what to do when an action is
performed. The following statements show how to add an `ActionListener`
to a button and implement its `actionPerformed()` method.

[source,java]
----
JButton chirp = new JButton("Chirp");
chirp.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //Code to perform an action goes here
            }
        });
----

The first line above creates a button named `chirp`. The second line
adds an action listener to the button. The process of adding an action
listener to an object is also known as _registering_ a listener on the
object. Note that the sole argument to this `addActionListener()` method
is a newly created `ActionListener` object. Inside this newly created
and anonymous `ActionListener` object, we implement the
`actionPerformed()` method. Whatever code we want to execute in response
to the clicking of the `chirp` button goes inside the
`actionPerformed()` method.

This syntax may look strange to you. `ActionListener` is an interface,
which cannot be instantiated. What is that `new` keyword doing? It's
doing something pretty amazing by creating an instance of an _anonymous
class_. On the fly, we're creating a class that has never existed
before. It doesn't even have a name. All we know about it is that it
implements the interface `ActionListener`.

Note that there are braces after the constructor call, defining what's
inside of this class. Inside, we have only created an
`actionPerformed()` method, but we could have created fields as well as
other methods. It's a little ugly to create a whole new class and
instantiate it in the middle of calling the `addActionListener()`
method, but it's also very convenient. We need to supply an object that
reacts to the event exactly the way we want it to. Since one doesn't
exist yet, we have to create it. Of course, it is possible to supply any
object that implements the `ActionListener` interface, not just
instances of anonymous classes. For more information about nested
classes, inner classes, and anonymous classes, refer to
<<Advanced: Nested classes>> and <<Advanced: Local and anonymous classes>>.

.GUI with actions
====

We now modify <<FrameWithPanelProgram>> to respond to button
clicks. When the `chirp` button is clicked, the program will display the
message "`Chirp requested.`" in the text field. Similarly, when the
`bark` button is clicked, the program will display "`Bark requested.`"

<<FrameWithPanelAndActionsProgram>> is largely the same as
<<FrameWithPanelProgram>>. It adds the same buttons and text
field but then adds an action listener to each button. The action
performed when the `chirp` and `bark` buttons are clicked is to display
a message in the text box. When the `exit` button is clicked, the
listener displays a message on the console and exits the program.

.Demonstrates handling of action events.
[source, java, linenums]
[[FrameWithPanelAndActionsProgram]]
----
include::{programsdir}/FrameWithPanelAndActions.java[]
----

Note that the sequence in which you add the buttons to the panel
determines the appearance of the GUI. The action listeners can be added
either before or after the panel has been set up but should be added
before the frame is made visible.

Do not be overly concerned with why the `final` keyword is used when
declaring `soundCheck` and `message`. You might be surprised that you
are even allowed to reference these local variables inside of the third
`ActionListener` class. An inner class has access to all the fields
inside of its outer class and access to local variables declared in the
same scope as the inner class. For technical reasons, any local variable
used in an anonymous inner class must be declared `final`. This
restriction does not apply to class variables.
====


.GUI with alternate action listener style
====

In the previous example we added an `ActionListener` object to each
button and implemented its `actionPerformed()` method with anonymous
inner classes. An alternate way to use `ActionListener` is to implement
`ActionListener` on the surrounding class and include an
`actionPerformed()` method exactly once instead of creating several
individual anonymous inner classes which each handle an event. Let's
examine one such implementation in
<<AlternateActionListenerProgram>> and contrast it with
<<FrameWithPanelAndActionsProgram>>. Note that both programs
generate exactly the same GUI and exhibit identical behavior.

.Demonstrates handling of action events by implementing `ActionListener` at the class level.
[source, java, linenums]
[[AlternateActionListenerProgram]]
----
include::{programsdir}/AlternateActionListener.java[]
----
<1> The constructor adds an `ActionListener` to each button. The listener added is `this`, specifying that the `AlternateActionListener` object is the one that will process any action event generated by the buttons. The remainder of the code for the constructor is essentially the same as that from the `main()` method in <<FrameWithPanelAndActionsProgram>>.
<2> A class that implements `ActionListener` must include an `actionPerformed()` method.  It has exactly one parameter, an `ActionEvent` object. Whenever an action event occurs, its attributes are bundled into an `ActionEvent` object and passed into the `actionPerformed()` method.
<3> Here the `getSource()` method is used to determine which object is responsible for the event. Variable `button` holds the object returned by
`getSource()`.
<4> These `if` statements compare `button` with `chirp` and `bark` to determine if either of these generated the event. Then a suitable message is displayed in the `message` box. If neither button generated the event, it must have been `exit`, and the frame disposes itself after displaying "`Exit`" on the console.
<5> The `main()` method simply creates an instance of `AlternateActionListener` and terminates. The program does not end because the threads for the GUI are still running.
====

It is instructive to note the differences between
<<FrameWithPanelAndActionsProgram>> and
<<AlternateActionListenerProgram>>. In
<<AlternateActionListenerProgram>>, most of the code has been
moved from the ` main()` method to the constructor. Various objects,
namely the `soundCheck` frame, the `soundPanel` panel, all three
buttons, and the text box are now fields of the object instead of local
variables in the `main()` method. This removes the need to mark
`soundCheck` and `message` as `final`.

We have examined two ways of adding an `ActionListener` to a Java
program. The choice of which style to use depends on your needs. Adding
an anonymous `ActionListener` to each object can require you to use the
`final` keyword to reference local variables, but it is otherwise quick
and easy. Using a named class (often the main program class or a
subclass of `JFrame`) as the `ActionListener` allows you to handle many
events in a centralized location. It can be easier to find errors when
all events are handled in one `actionPerformed()` method, but the method
can become long and complex as well.

****
<<widgetAddingOrderExercise>>
****

===== The `MouseListener` interface

Clicking a button is great, but a mouse can be used to generate other
events too. For example, in a screen full of pictures, you might want to
highlight a picture when the cursor hovers over it. Or you might want to
create a drawing program which uses a mouse as a pen. To process general
mouse events, we need an object that implements the `MouseListener`
interface, which defines the following methods.

* `mouseClicked()`
* `mouseEntered()`
* `mouseExited()`
* `mousePressed()`
* `mouseReleased()`

The function of each method is implied by its name. The `mouseEntered()`
event fires when the mouse cursor moves from outside of the area covered
by a widget into the area above it. Conversely, the `mouseExited()`
event fires when a mouse cursor was over a widget and has just moved
away. The `mousePressed()` event fires when a mouse button is pressed
over a widget. The `mouseReleased()` event fires when a mouse button is
released over a widget. The `mouseClicked()` event is a combination of
both the `mousePressed()` and `mouseReleased()` events, occurring only
if a mouse button was pressed and then released while the cursor was
over a widget. As you can see, a widget only fires events when the
cursor is over the component (or has just left). Thus, a widget only
reports events that have to do with it, not the general state of the
mouse.

Each method in `MouseListener` receives a `MouseEvent` object as its
argument. To handle mouse events, a class must implement the
`MouseListener` interface. This is similar to the implementation of the
`ActionListener` interface from the previous section, but implementing
`MouseListener` requires a definition for *each* of the five methods
listed above. The next example illustrates `MouseListener` in use.

[[mouseListenerExample]]
.Mouse listener
====

We can write a program that displays a GUI containing two buttons labeled
"`One`" and "`Two.`" In addition a text box displays a suitable message
when the cursor enters a button. When a button is clicked, the status
box should display the total number of times that button has been
clicked so far.

.Demonstrates the handling of mouse generated events using the `MouseListener` interface.
[source, java, linenums]
[[SimpleMouseEventsProgram]]
----
include::{programsdir}/SimpleMouseEvents.java[]
----
<1> We declare class `SimpleMouseEvents`, implementing the `MouseListener` interface. The following few lines declare frame `frame`, buttons `one` and `two`, and a text box `status`. Two integers `oneClicks` and `twoClicks` are initialized to 0 and are used to keep track of the number of times each button has been clicked.
<2> The first line of the `SimpleMouseEvents` constructor creates the panel
`panel`. It doesn't need to be a field, and it's always preferable to
keep a variable local if it can be. The next two lines add a `MouseListener` to the two buttons. Note the use of `this` in the argument to `addMouseListener()` which refers to the object being created by the constructor. Next, the panel is set up and added to the frame. Finally the frame size and its default close operations are set, and the frame is made visible.
<3> The `mouseEntered()` method is invoked when the cursor enters either of the two buttons. First we retrieve the source of the event using the `getSource()` method and identify which object generated the event. A suitable message is displayed in the status box using the `setText()` method.
<4> The `mouseClicked()` method is invoked when the mouse cursor is placed over a button and clicked. As before, we retrieve the source of the event using the `getSource()` method. A suitable message, including the number of clicks, is displayed in the text box. Of course, recording the button clicks could have been done with an `ActionListener` instead.
<5> The only job of the `main()` method is to create an instance of
`SimpleMouseEvents`.

<<SimpleMouseEventsProgram>> generates the GUI shown in
<<simpleMouseEventsFigure>>.

[[simpleMouseEventsFigure]]
[.text-center]
.GUI consisting of two buttons and a text box. Button clicks and entry of the cursor into a button are reported by the text box.
image::simpleMouseEventsFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]
====

****
<<mouseEventsExercise>>
****

===== Mouse adapter

Creating a `MouseListener` requires all five methods in the interface to
be implemented. In some cases, as in <<mouseListenerExample>>,
there is no need to implement all the methods because we are not
interested in all the corresponding events. In such situations we are
forced to include the methods without any statement in the method body.
However, you might want to include the methods only when they are
needed. The `MouseAdapter` abstract class helps us avoid implementing
methods we do not need.

`MouseAdapter` is an abstract class, unlike the `MouseListener`
interface. The advantage of using `MouseAdapter` is that it already
provides a skeletal implementation of each method needed to process
mouse events. We can override these implementations as needed, and we do
not need to provide an implementation of a method that is not used.

.Mouse adapter
====

<<SimpleMouseAdapterProgram>> is a revised version of
<<SimpleMouseEventsProgram>>. Remember that an abstract class is *extended* whereas an interface is *implemented*.

.Handles mouse generated events using the `MouseAdapter` abstract class.
[source, java, linenums]
[[SimpleMouseAdapterProgram]]
----
include::{programsdir}/SimpleMouseAdapter.java[]
----
<1> Class `SimpleMouseAdapter` extends the abstract class `MouseAdapter`. Thus, it inherits all the empty methods defined in `MouseAdapter`.
<2> We override the method `mouseEntered()`.
<3> We override the method `mouseClicked()`.  No other methods need to be overridden in this example.
====

****
<<MouseAdaptorExercise>>
****

===== Other event listeners

In this chapter we describe two types of listeners in Java,
`ActionListener` and `MouseListener`. You may have noticed that none of
the mouse events we discussed involved the movement of the mouse inside
of the component, only whether it was entering or exiting the component.
Because tracking mouse movement is more computationally expensive than
tracking presses, releases, enters, and exits, Java uses yet another
listener to handle mouse movement, `MouseMotionListener`. It contains
the methods `mouseDragged()` and `mouseMoved()`, which are used to
handle mouse movement with or without the button pressed.

An `ItemListener` can be attached to a widget such as a check box or a
radio button to listen for a check box to be selected. This listener is
illustrated in <<Applets>>.

Java provides several other listeners to handle a variety of events. For
example, the `DocumentListener` can be attached to a `JTextField` or a
`JTextArea` object to listen to document events, which include the
`insertUpdate()` event that is fired when a character is inserted the
text box. A `KeyListener` can also be attached to text boxes to listen
to key events such as the return key being typed, which can have similar
functionality. These events could be useful while writing a text editor
application, for example.

After you have mastered the contents of this chapter, you may plan to
write more complex GUIs than the ones we discuss. For further
information, you may wish to follow the Java tutorial on writing event
listeners at the Oracle
http://download.oracle.com/javase/tutorial/uiswing/events[Swing Events tutorial site^].

==== Adding sounds and images

Sounds and images can also be added to a Java GUI application. While
Java offers a rich set of sound APIs, we restrict our examples to
playing sound clips from audio files that come in `au` or `wav` formats.
We also introduce the `ImageIcon` class to create icons from image
files.

===== Sounds

First, let's see how to define an audio clip.

[source,java]
----
AudioClip chirpClip = Applet.newAudioClip(chirpURL);
----

This statement declares `chirpClip` with type `AudioClip`. It
instantiates `chirpClip` using the `newAudioClip()` method found in the
`Applet` class in the `java.applet` package. Note that the argument to
the `newAudioClip()` method is an object of type `URL`. URL stands for
_universal resource locator_. It serves as a web address from which
files can be retrieved. A `URL` object can be defined as follows.

[source,java]
----
URL chirpURL =
    new URL("http://users.etown.edu/w/wittmanb/chirp.wav");
----

Above we specify the full URL to access an audio file named `chirp.wav`.
Alternately you can give the file name from a local directory.

[source,java]
----
URL chirpURL = new URL("file:sounds/chirp.wav");
----

The prefix `file:` indicates that the `chirp.wav` file is in a local
directory. Once a clip has been declared and loaded, it can be played as
follows.

[source,java]
----
chirpClip.play();
----

This command will play the clip in `chirpClip` loaded from the specified
URL, exactly once. If you want to play the clip in a loop, use the
`loop()` method.

[source,java]
----
chirpClip.loop();
----

To stop a clip from playing, use the `stop()` method.

[source,java]
----
chirpClip.stop();
----

Now that we have seen how to declare, load, play, and stop an audio
clip, we are ready to write a more interesting version of
<<FrameWithPanelAndActionsProgram>>.

[[soundGameExample]]
.Sound game
====

We can rewrite <<FrameWithPanelAndActionsProgram>> so that the
new program plays the sound clips in a loop when the corresponding
button is clicked. Think of the new program as a Java version of the
pull-string toys that children use to play animal sounds. Our program
only has two sounds, but more could be added.

[[soundGameFigures]]
[.text-center]
.GUI for the sound game application. (a) On program start. (b) After the "`Chirp`" button has been clicked and the clip is playing.
image::soundGameFigures.svg[scaledwidth=80%,pdfwidth=80%,width=80%]

We will add a new button labeled "`Stop Sound`" that stops the playback
of sounds when clicked. Let's assume that this program is only allowed
to play one sound at a time. When it starts, the GUI will look like
<<soundGameFigures>>(a). Note that the `stop` button is gray,
indicating that it is disabled.

The complete program for the game is shown in
<<SoundGameProgram>>. Because most of this program is similar
to <<FrameWithPanelProgram>>, we will only look at the
differences.

.Animal sound game.
[source, java, linenums]
[[SoundGameProgram]]
----
include::{programsdir}/SoundGame.java[]
----
<1> We start with the `stop` button disabled.
<2> Here we define the action listener for the `chirp` button, which
disables the `bark` button, tells the user that the chirp sound is playing, plays the sound, and enables the `stop` button.
<3> The action listener for the `bark` button is similar.
<4> The action listener for the `stop` button does not know what sound is playing, so it stops both sounds and then disables the
stop button.
<5> The action listener for the `exit` button prints "`Exit`" and disposes the frame.

When the `chirp` button is clicked, the GUI looks like <<soundGameFigures>>(b). An exercise asks you to modify the program so that the action listener associated with the `stop` button knows which sound is
playing.
====

****
<<animalSoundsExercise>> +
<<stopPlayingSoundExercise>>
****

===== Images and icons

Images are often useful when creating GUIs. In this section we show you
how to use images to create icons and then use the icon to decorate
buttons and labels. First, let's see how an icon object can be created.
Suppose we have a picture file named `smile.jpg` in a directory named
`pictures`. Note that the `pictures` directory should be located in same
directory as the class files for the program. The following statement
creates an object of type `ImageIcon` from this picture.

[source,java]
----
ImageIcon smileIcon = new ImageIcon("pictures/smile.jpg");
----

Note that the file name, along with its path, is passed to the
`ImageIcon` constructor as a string. Now we can add the image to a
button.

[source,java]
----
JButton smile = new JButton();
smile.add(smileIcon);
----

Similarly you can add an image icon to a label. The next example gives a
simple program that creates a button with an image.

****
<<selfieExercise>>
****

.Icon example
====

<<IconExampleFigure>> shows a GUI with a button decorated with a
picture. <<IconExampleProgram>> gives the code to create this
GUI using the `ImageIcon` class.

[[IconExampleFigure]]
[.text-center]
.A GUI with a button decorated by an image icon.
image::iconExampleFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]

.Creates a GUI with a button decorated by a picture.
[source, java, linenums]
[[IconExampleProgram]]
----
include::{programsdir}/IconExample.java[]
----
<1> An image icon is created from a JPEG file named `smile.jpg` located in
the `pictures` directory.
<2> We create a button named `smile` and decorate it with the icon by supplying it as an argument to the `JButton` constructor. Note that, if the file cannot be found, the program will fail _quietly_. This means that no exception is thrown. Instead, the button will appear with no image.

The remaining lines add the button to the frame, set the frame size and its default close operation, and make the frame visible.
====

****
<<iconSoundsExercise>>
****

===== Labels, icons, and text

In some applications you might want to show a picture with an attached
text label. For example, in a shopping cart for an online clothing
store, you might have seen pictures of clothes, each labeled with a name
and a price. The `JLabel` class is flexible, able to display text alone,
an image alone, or both. Note that a `JLabel` is only for displaying
information and is incapable of firing events or reading user input.

Here are three different ways to create a label.

[source,java]
----
ImageIcon hibiscus = new ImageIcon("pictures/hibiscus.jpg")
JLabel textOnly = new JLabel("Text only");
JLabel flower = new JLabel(hibiscus);
JLabel labeledflower = new JLabel("Red Hibiscus", hibiscus, JLabel.CENTER);
----

The first `JLabel` constructor above creates a label displaying only
text, namely, "`Text only.`" The second constructor creates a label
decorated with an icon created from a picture. The third constructor
creates a label with the same icon and additional text. Note the last
argument in this third case. `JLabel.CENTER` is a constant that
specifies that the content of the label (both the image and the text)
should be placed horizontally in the center of the label. A horizontal
alignment of left or right can also be specified using the constants
`JLabel.LEFT` or `JLabel.RIGHT`, respectively. These three horizontal
alignment indicators are some of the many constants found in Swing.

Sometimes you might want to place the text below the icon that decorates
the label. This can be done as follows by setting the horizontal and
vertical positions of the text.

[source,java]
----
flower.setVerticalTextPosition(JLabel.BOTTOM);
flower.setHorizontalTextPosition(JLabel.CENTER);
----

.Label example
====

<<labelExampleFigure>>(a) is generated by executing Program 
<<LabelExampleProgram>>.

[[labelExampleFigure]]
.(a) A GUI with a label decorated by an image icon and a title beneath it. (b) The GUI with unaligned text.
image::labelExampleFigure.svg[scaledwidth=100%,pdfwidth=100%,width=100%]


.Creates a GUI with a label decorated by a picture and text.
[source, java, linenums]
[[LabelExampleProgram]]
----
include::{programsdir}/LabelExample.java[]
----
<1> Vertically position the text on the bottom of the label.
<2> Horizontally center the text on the label.

You will see the GUI shown in
<<labelExampleFigure>>(b) if the alignment instructions on these two lines are omitted.
====

==== Layout managers

Java provides a number of _layout managers_ to assist with the design of
GUIs. A layout manager is an object that controls the placement of
widgets on a frame or panel. Every container has a default layout
manager, but it is possible to set it to other ones. In this section we
will introduce the three layout managers `FlowLayout`, `GridLayout`, and
`BorderLayout`. Java also provides several other layout managers, each
designed for different layouts.

===== `FlowLayout`

The `FlowLayout` manager is one of simplest layout managers. When a
container is using the `FlowLayout` manager, widgets will be added in
order from left to right. When there is no more space, subsequent
widgets will be added starting on the next row. In addition, each row of
components is centered within the container. The `JPanel` container uses
`FlowLayout` by default, but it is possible to set it explicitly as
well.

[source,java]
----
JPanel panel = new JPanel(new FlowLayout());
----

When we have added more than one widget to a `JFrame` in previous
examples, we have first added them to a `JPanel`. The reason we have
done so is because `FlowLayout` is the default layout manager for
`JPanel` containers. Although every `JFrame` has a container, it uses
the `BorderLayout` manager by default, which would have complicated our
examples. The next example illustrates `FlowLayout` further.

.FlowLayout
====

<<FlowLayoutExampleProgram>> creates a GUI with several
buttons.

.Adds several buttons using `FlowLayout`.
[source, java, linenums]
[[FlowLayoutExampleProgram]]
----
include::{programsdir}/FlowLayoutExample.java[]
----
<1> We first create a frame.
<2> We create a panel and set its layout manager to `FlowLayout`.
<3> This `for` loop is used to create new buttons, label them appropriately, and add them to the panel.

The `Flowlayout` manager neatly places the buttons along a number of rows depending on the width of the frame. The GUI created is shown in <<FlowLayoutExampleFigure>>.

[[FlowLayoutExampleFigure]]
[.text-center]
.Using the `FlowLayout` manager to generate a GUI containing six buttons.
image::flowLayoutExampleFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]
====

****
<<resizingGUIExercise>> +
<<packedGUIExercise>>
****

===== `GridLayout`

The `GridLayout` manager lays out components in a grid with a set number
of rows and columns. As with other layout managers, `GridLayout` can be
applied to frames and panels.

[source,java]
----
JFrame frame = new JFrame("Grid Layout");
frame.setLayout(new GridLayout(3, 2, 5, 5));
----

This snippet creates a frame named `frame` and sets its layout manager
to `GridLayout`. The first two arguments to `GridLayout` give the number
of rows and columns, respectively. The last two arguments give the
horizontal and vertical gaps between the neighboring cells in the grid.
In this example the frame will contain a total of six cells organized
into three rows with two columns.

[[gridLayoutLToRFigure]]
[.text-center]
.A 3 × 2 grid layout containing six buttons using left to right orientation.
image::gridLayoutLToRFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]


<<gridLayoutLToRFigure>> shows how `frame` will look after six
buttons, labeled 0 through 5, have been added to it in that order. A key
feature of using a `GridLayout` is that all cells in the grid will be
the same size and will stretch to fill the entire container. Also note
the equal spacing between the neighboring cells. It is possible to add
more or fewer cells than specified in the `GridLayout` constructor, but
the layout manager will be forced to guess at your intentions.

****
<<GridLayoutExercise>>
****

.Animal identifier
====

We can write a program to displays pictures of animals and identify
which animal the mouse is current hovering over. The animal's name will
be displayed in the title of the frame.
<<animalIdentifierFigure>> shows this GUI.

[[animalIdentifierFigure]]
[.text-center]
.A GUI for an animal identifier. Note that the bison is identified according to the frame title.
image::animalIdentifierFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]

<<AnimalIdentifierProgram>> creates the GUI shown in
<<animalIdentifierFigure>>.

.Identifies which animal is in various images when the mouse hovers over the image. Images are laid out using a `GridLayout` manager.
[source, java, linenums]
[[AnimalIdentifierProgram]]
----
include::{programsdir}/AnimalIdentifier.java[]
----
<1> Class `AnimalIdentifier` declares four labels and a frame as fields. The labels are named `bison`, `dove`, `gecko`, and `spider`.
<2> Inside the constructor, we create a panel with a 2 × 2 `GridLayout`. Then, we create four image icons, one to decorate each label.
<3> Each of the four labels is created with its respective icon. We also add a `MouseListener` to each label.
<4> The buttons are added to the panel, and the panel is added to the frame.
<5> The last few lines set the size of the frame, pack it, set its close operation, and make it visible.
<6> Since `AnimalIdentifier` implements `MouseListener`, we need to define
all the methods in the `MouseListener` interface. As we are only interested in displaying the name of a picture when the mouse moves over it, the
`mouseEntered()` method is where most of our event handling code will be.
<7> We get the label the mouse entered. We compare this label to the four labels and change the frame title correspondingly.

We implement the remaining methods from `MouseListener` to report the
event on the console. The `main()` method creates a new instance of
class `AnimalIdentifier`, launching the GUI.

Play with <<AnimalIdentifierProgram>>. What happens when you
resize the window?
====

****
<<hoverSoundExercise>>
****

===== `BorderLayout`

The `BorderLayout` manager is the default one for a `JFrame`. It allows
components to be laid out spatially in regions of a container. These
regions are north, south, east, west, and center. This layout is
intuitively easy to understand, but it is difficult to describe
precisely.

You can only add one component to each region of the layout, and adding
a component to any region is optional. The regions will stretch or
shrink to accommodate the components inside. The north and south regions
will only be as tall as needed to hold their contents, but their width
will stretch as wide as the entire container. The east and west regions
will only be as wide as needed to hold their contents, but their height
will stretch as tall as needed to fit the remaining height of the
container. Both the height and the width of the center region will
stretch as big as it needs to fill the container.

.BorderLayout
====

Here is an example of a frame using `BorderLayout`. Five buttons have
been added, one to each region, using the program shown below.

.Shows buttons laid out in each of the five regions of a `BorderLayout`.
[source, java, linenums]
[[BorderLayoutExampleProgram]]
----
include::{programsdir}/BorderLayoutExample.java[]
----

[[borderLayoutFigure]]
[.text-center]
.A GUI demonstrating `BorderLayout` generated by <<BorderLayoutExampleProgram>>.
image::borderLayoutFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]


Unlike `FlowLayout` or `GridLayout`, the location must be specified to
add a component to a `BorderLayout`. (There is an overloaded `add()`
method to add a component to specific grid cell in a `GridLayout`, but
it is not necessary to use it.) With `BorderLayout`, the `add()` method
uses a second parameter, which is `BorderLayout.NORTH`,
`BorderLayout.SOUTH`, `BorderLayout.EAST`, `BorderLayout.WEST`, or
`BorderLayout.CENTER`, depending on where you want to add the component.
If you do not specify a second parameter, the component will be added to
the center region. Since only one component can be in each region,
adding a component to a region that is already occupied will replace the
old component with the new one.

====

At first glance, `BorderLayout` seems that it would rarely be useful.
However, this layout is commonly used because it can be used to
establish a spatial relationship between different parts of a GUI. A
container with a `BorderLayout` generally has other containers with
their own layouts added to its regions, as shown in the following
example.

.Calculator layout
====

We can make a GUI application that functions as a simple calculator. The
calculator has the ten digits 0-9, a plus button, a minus button, and an
enter button. At the top is a display that shows the current value.

We create ten `JButton` objects for the digits and three more `JButton`
objects for plus, minus, and enter. The display is a `JLabel`. The code
is given below.

.Lays out a simple calculator.
[source, java, linenums]
[[CalculatorLayoutProgram]]
----
include::{programsdir}/CalculatorLayout.java[]
----

[[calculatorLayoutFigure]]
[.text-center]
.GUI generated by <<CalculatorLayoutProgram>>.
image::calculatorLayoutFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]

This program uses a `BorderLayout` to put a container with a
`GridLayout` in a spatial arrangement with other components. First, we
put the ten digit buttons in a panel with a `GridLayout` having 4 rows
and 3 columns. We put the plus button and the minus button in the
remaining two cells of the grid. We add this grid panel to the larger
panel in the center region. We put the enter button in the south region
and the display in the north region.

====

There is no limit to how deeply you can nest containers within each
other. Sometimes you must create a very complex GUI using many
`BorderLayout` managers to achieve the appearance you want.

The three layout managers discussed in this section are the simplest,
but there are others. The `BoxLayout` manager is a useful tool for
laying out components in a stack or in a row. The `GridBagLayout`
manager can be used to create complex layouts in a single container
using a grid-based framework that is much more flexible than
`GridLayout`, but the complexity of programming `GridBagLayout` is
significant. The `SpringLayout` and `GroupLayout` managers are also
powerful, but they are designed for use with a GUI builder utility.

==== Menus

Menus provide a useful form of interface that is expected from most GUI
applications. In this section we show how to create menus and respond to
the selection of menu items. Menus are placed on a menu bar. Each menu
usually consists of several menu items that could be selected by the
user. In addition to simple text, a menu item can be a button, a radio
button, check box, or an icon. A menu can have one or more sub-menus
opening out of a menu item.

===== Creating menus

First we have to create a menu bar.

[source,java]
----
JMenuBar bar = new JMenuBar();
----

This statement creates an object of type `JMenuBar` named `bar` which
can hold menus. A `JFrame` has only one menu bar. We can create several
menus and add them to the menu bar.

[source,java]
----
JMenu type = new JMenu("Type");
JMenu operations = new JMenu("Operations");
bar.add(type);
bar.add(operations);
----

These statements create two menus named `type` and `operations` labeled
"`Type`" and "`Operations,`" respectively. The two menus are added to
the existing menu bar using the `add()` method. Menus can be populated
with menu items as follows.

[source,java]
----
JMenuItem addition = new JMenuItem("Addition");
JMenuItem subtraction = new JMenuItem("Subtraction")
operation.add(addition);
operation.add(subtraction);
----

These statements create two menu items named `addition` and
`subtraction`. These menu items are then added to the menu `operations`.
After having created a menu bar together with its menus and their
respective menu items, we need to add it to a frame.

[source,java]
----
JFrame frame = new JFrame("Menu Example");
frame.setJMenuBar(bar);
----

These statements create a frame and set its menu bar to `bar`. It is
possible to use the `add()` method instead of the `setJMenuBar()` method
to add a `JMenuBar` to a `JFrame`. However, doing so will add the
`JMenuBar` to the regular content area, *not* to the menu area.

****
<<JMenuBarExercise>> +
<<addMenuBarExercise>>
****

Sometimes you might need to disable a menu item and enable it only under
certain conditions.

[source,java]
----
JMenuItem subtraction = new JMenuItem("Subtraction");
subtraction.setEnabled(false);
----

These statements create a menu item named `subtraction` and disable it.
A disabled menu item shows as a gray item and does not respond to
attempts to select it. Note that `JButton` objects and many other
widgets can be disabled in the same way.

===== Adding events to menus

An action listener can be added to each menu item, just like a
`JButton`. Then, when a menu item is clicked by the user, an action
event is generated. A `JCheckBoxMenuItem` object can be added to a
`JMenu` as well. This object will have a check box which can be selected
or unselected. A regular `JMenuItem` object generates an `ActionEvent`
which is handled by an `ActionListener`. A `JCheckBoxMenuItem`, however,
generates an `ItemEvent` handled by an `ItemListener`. Here are examples
of both situations.

[source,java]
----
JMenuItem subtraction = new JMenuItem("Subtraction");
JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem("Check yourself");
subtraction.addActionListener(this);
checkbox.addItemListener(this);
----

A `JMenuItem` works just like a `JButton`. In fact, the same action
listener code could handle events for both buttons and menu items.
However, a `JCheckBoxMenuItem` generates an `ItemEvent` (like many other
check box and list widgets that we do not discuss) when the state of its
check box changes. Thus, when you select a check box, a
latexmath:[\surd] sign appears to its left and an `ItemEvent` is
generated. When you select an already checked check box, the sign
disappears and another `ItemEvent` is generated. Although an
`ActionEvent` and an `ItemEvent` are very similar, Java differentiates
between them because an `ItemEvent` has more information: By using the
`getStateChange()` method, it is possible to tell whether the widget
that fired the `ItemEvent` is now selected or deselected.

.Math tutor
====

Here we give the code to generate the GUI shown in
<<MathTutorFigure>> which displays basic (addition and
subtraction) as well as advanced (multiplication and division) problems.
In <<Applets>> we transform this GUI into an applet
like the one described in <<Problem: Math applet>>.

[[MathTutorFigure]]
.GUI for the `MathTutor`. (a) No menu selected. (b) Type selected. (c) Operations selected.
image::mathTutorFigure.svg[scaledwidth=100%,pdfwidth=100%,width=100%]


As shown in <<MathTutorFigure>>, this GUI has a menu bar
consisting of two menus labeled "`Type`" and "`Operations.`" The
"`Type`" menu contains a check box labeled "`Advanced`" while the
"`Operations`" menu contains four menu items labeled "`Add,`"
"`Subtract,`" "`Multiply,`" and "`Divide.`" Note that the "`Multiply`"
and "`Divide`" menu items are disabled. They will be enabled when the
user selects the "`Advanced`" check box.

Before we introduce the program that creates this GUI, we need a helper
class called `ProblemGenerator` that can randomly generate arithmetic
problems. The class is designed so that the answers are always positive
integers.

.Utility class to generate random addition, subtraction, multiplication, and division problems.
[source, java, linenums]
[[ProblemGeneratorProgram]]
----
include::{programsdir}/ProblemGenerator.java[]
----

The code listed above has four static methods `addPractice()`,
`subtractPractice()`, `multiplyPractice()`, and `dividePractice()`. Each
method generates an appropriate math problem, sets an input `JLabel` to
display the problem, and returns the solution. Note that `\u00D7` and
`\u00F7` are the Unicode values for the multiplication and division
symbols.

<<MathTutorProgram>> generates the GUI in
<<MathTutorFigure>>.

.Uses menus to generate math problems.
[source, java, linenums]
[[MathTutorProgram]]
----
include::{programsdir}/MathTutor.java[]
----
<1> Class `MathTutor` begins by creating only the objects that need to interact with event handlers: four menu items, a label, a text field, and a button.
<2> Inside the `MathTutor` constructor, the frame and remaining widgets are
created.
<3> Action listeners are added to the four operations menu items. An item listener is added to the "`Advanced`" check box menu item, because it requires a different kind of event handler. Note that `MathTutor` implements both the `ActionListener` and `ItemListener` interfaces, allowing it to handle both kinds of events.
<4> The two menus are populated with their respective menu items.
<5> The `multiply` and `divide` menu items are disabled because the application starts in basic mode.
<6> The menus are then added to the menu bar, and the menu bar is set on the frame. Finally, the label and text field are added to the frame, which is made visible. Note that these two widgets are added directly to the frame with the parameters `BorderLayout.NORTH` and `BorderLayout.SOUTH`. `JFrame` objects use the `BorderLayout` manager by default.
<7> The `itemStateChanged()` method enables the `multiply` and `divide` menus and disables the `add` and `subtract` menus if the `advanced` check box is selected and does the reverse if it has been unselected.
<8> The `actionPerformed()` method is similar to earlier examples. Depending on which menu item fired the event, the appropriate static methods from the `ProblemGenerator` class are used to display a math problem on `label`.
<9> The `main()` method creates an instance of `MathTutor`, initiating GUI construction.
====


==== Applets

An applet is a Java program that is written to run inside a web browser.
A normal Java application is stored on disk and runs on the command line
or as a window on your desktop (or both), but an applet exists inside of
a webpage. This means that the code that launches an applet is usually
embedded in HTML code.

Almost all of the GUI tools we discuss are useful for writing an applet.
For example, you can write an applet that has menus, buttons, text
fields, and any other widget that Swing offers. You can also add
listeners to various objects for the applet to respond to events.

A Swing applet is derived from the `JApplet` class, which is a subclass
of the older AWT class `Applet`.

An applet differs from a stand-alone Java application in several
important ways. The first is that applets are sent across the Internet.
Unless you have increased security settings on your browser, they will
generally run as soon as you visit a page with an applet embedded in it,
without even asking your permission. This poses a huge security risk,
but the designers of Java have worked to protect us. Unsigned applets
(which are the ones we will talk about creating) cannot read, write, or
execute files, make network connections to servers other than the one
they come from, or interact with most other local system settings.
However, applets loaded from a local directory (instead of downloaded
over the Internet) do not have these restrictions. Be sure to remember
these restrictions when you design applets for distribution over the
Internet.

Another important and concrete difference from normal Java classes is
that an applet should not define a constructor. Instead, an applet uses
the `init()` method. When the applet is executed, often through a
browser, its `init()` method is called first. You can use this method to
set up the applet GUI by adding various widgets and event listeners.

[[rainbowAppletExample]]
.`RainbowApplet`
====

We can create a simple applet with a button and a label. Clicking this
button sets the text on the label to contain some information about the
colors in a rainbow. This applet is shown in
<<rainbowAppletFigure>>. <<RainbowAppletProgram>>
defines the applet.

[[rainbowAppletFigure]]
[.text-center]
.A simple applet containing one button.
image::rainbowAppletFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]


.Applet with a button and a label.
[source, java, linenums]
[[RainbowAppletProgram]]
----
include::{programsdir}/RainbowApplet.java[]
----

Note that class `RainbowApplet` extends `JApplet`, as will most applets
you write. The label is declared as a field, so that the event handler
can access it. The `init()` method creates a `JButton` with the label
"`Rainbows,`" adds both the label and the button to the applet, and adds
an action listener to the button with an anonymous inner class event
handler.

Note that the button and the label were added to the applet just as it
would have been done inside of a `JFrame` constructor. They were added
with the `BorderLayout.WEST` and `BorderLayout.EAST` constants because a
`JApplet` uses a `BorderLayout` manager by default.

====

As you can see, creating an applet is very similar to creating a GUI
based on a `JFrame`. In fact, it may be easier. However, we need to
create an HTML file for the applet to be accessible via a browser. HTML
stands for _hypertext markup language_. HTML is the core language for
writing webpages. HTML is designed for marking up text and images to be
displayed within a browser. It is not as complicated as Java, but we do
not have time or space to describe the language deeply.

HTML is a language made up of _tags_ that mark parts of a document with
formatting instructions. All of the tags we will need to embed an applet
will start with the name of the tag in angle brackets and then end with
the same name in angle brackets but preceded by a slash. For example, to
mark text as bold in HTML, you can use the `<strong>` tag as follows:

[source,java]
----
<strong>Here is text that will appear in a bold font.</strong>
----

To run `RainbowApplet` we need to create an HTML file that includes the
applet's class file inside the `<applet>` tag.

.RainbowApplet HTML
====

We want to make `RainbowApplet` executable via a browser. In addition,
we would like the source code of the applet to be linked from the same
webpage. The following HTML code embeds the `RainbowApplet` and links to
its source.

[source,java]
----
<html>
    <head>
        <title>Rainbow Applet</title>
    </head>
    <body>
        <applet code="RainbowApplet.class" width="200" height="100"></applet>
        <hr /><a href="RainbowApplet.java">The source.</a>
    </body>
</html>
----

[[rainbowAppletInBrowserFigure]]
[.text-center]
.The `RainbowApplet` as seen through a web browser. Clicking on the link displays the Java source code of the applet in <<RainbowAppletProgram>>.
image::rainbowAppletInBrowserFigure.png[scaledwidth=60%,pdfwidth=60%,width=60%]


An `<html>` tag encloses an entire HTML document. Inside is the `<head>`
tag, followed by the `<body>` tag. The `<head>` tag contains information
about the page such as its title, which is given in the `<title>` tag.
The `<body>` tag contains the viewable content of the web page. In this
case, there is an `<applet>` tag, a `<hr/>` tag, and an `<a>` tag in the
body.

The `<applet>` tag is used to embed our applet. The name of the applet
class must be given as the argument, in double quotes, to the `code`
attribute. The `width` and `height` attributes specify the size of the
applet on the screen. The `<hr/>` tag puts the horizontal line between
the applet and the link. It is the only tag in our example that does not
have both an opening and closing half. Finally, the `<a>` tag is used to
make a clickable link. On a web page, it will display "`The source,`"
but it will navigate to the file `RainbowApplet.java` when clicked.

Put this code in an HTML file named `RainbowApplet.html`. (Note that the
name of your HTML file should be descriptive, but it does not have to
match the name of the applet class.) If your browser is Java compatible
and has the appropriate plug-in installed, you should be able to run the
applet by double-clicking on the HTML file. Of course, if you are able
to upload the HTML file and the class file to a web server, you can view
the applet and share it with anyone with an Internet connection.
====

****
<<appletExercise>>
****

Applets can be much more complex than `RainbowApplet`. We now solve the
problem posed at the beginning of the chapter with an applet with a
fully functional GUI designed to be an arithmetic tutor.

=== Solution: Math applet

The applet that meets the specification given at the beginning of the
chapter is similar to <<MathTutorProgram>>. Modifications must
be made to convert that program into an applet and add full
functionality to the event handlers. We now go through this rather long
Java program step by step. GUI programs in Java tend to be longer than
their command line versions because of the code needed to set up all the
widgets.

[[menusInArithPracticeFigure]]
[.text-center]
.The Type (a) and Operations (b) menus in the `MathTutorApplet`. Note that the "`Multiply`" and "`Divide`" operations are disabled because the "`Advanced`" option is not checked.
image::menusInArithPracticeFigure.svg[scaledwidth=80%,pdfwidth=80%,width=80%]


The `MathTutorApplet.java` file begins with the usual Swing imports and
the class declaration, followed by a list of its fields.

[source, java]
----
include::{programsdir}/MathTutorApplet.java[lines=1..17]
----


Note that the `int` variables `correct`, `incorrect`, and `answer` have
been added to the fields to keep track of the correct and incorrect
answers and the current answer that the user is trying to find.

Following the field declarations is the definition of the `init()`
method. As you can see, this method is almost identical to the
constructor in the `MathTutor` stand-alone application. Indeed, the
`init()` method is very much like the constructor for an applet.

[source, java]
----
include::{programsdir}/MathTutorApplet.java[lines=19..52]
----


Just like the `MathTutor` constructor, this method creates the menu bar,
the menus, and the menu items. Then, it adds action listeners to the
menu items and the button and an item listener to the check box menu
item. Next it adds `advanced` to the "`Type`" menu and the four
operation menu items to the "`Operations`" menu. It disables the
advanced menu items (since the applet starts in basic mode) and the
button (since it is impossible to submit an answer before a problem has
been given). Finally, it puts the menus on the menu bar, sets the menu
bar on the applet, and adds the two text fields, the label, and the
button to the applet content area using appropriate `BorderLayout`
constants.

One big difference between the `MathTutor` constructor and the
`MathTutorApplet` `init()` method is that the `MathTutor` constructor
creates a `JFrame` object. In `MathTutorApplet` no `JFrame` is necessary
because the class itself is a child of `JApplet` and thus is a GUI
container.

[source, java]
----
include::{programsdir}/MathTutorApplet.java[lines=54..67]
----

The `itemStateChanged()` method is the same as its counterpart in
`MathTutor`. If the state change is `ItemEvent.SELECTED`, we enable the
advanced menus and disable the basic ones. Otherwise, we do the reverse.
Note that this method would be more complicated if we were listening to
more than one object. Since we are only listening to the `advanced`
check box menu item, we know that it is what is being selected or
deselected.

[source, java]
----
include::{programsdir}/MathTutorApplet.java[lines=69..95]
----


Finally, the `actionPerformed()` method deals with the menu item and
button clicks. If `submit` was clicked, we parse the text in the text
field to get an `int` value and compare it to the answer. Depending on
its correctness, we update the correct and incorrect counts, clear the
problem label, and update the `score` label. Finally, we disable the
`submit` button so that the user can't submit an answer until another
problem has been given.

The next part of the `actionPerformed()` method has the same
functionality as the `actionPerformed()` method from `MathTutor`. It
updates `label` to contain a randomly generated problem with an
operation that matches whichever menu item was picked. It also saves the
answer into the `answer` field so that we can check the user's response
later. Then, it enables the `submit` button since there is a problem to
answer. No matter what object triggered the action, the last line of the
method clears the text field.

We need some HTML to test the applet. Here is a suitable HTML file
similar to the `RainbowApplet.html` file presented before.

[source,java]
----
<html>
    <head>
        <title>Math Tutor Applet</title>
    </head>
    <body>
        <applet code="MathTutorApplet.class" width="250" height="125"></applet>
        <hr /><a href="MathTutorApplet.java">The source code.</a>
    </body>
</html>
----

In the stand-alone `MathTutor` application, we created a `JFrame` and
set its size to 250 × 125 pixels. The `width` and
`height` attributes in the HTML allow us to accomplish something
similar. Note that the widgets in the applet have more room than in the
`JFrame` version because the size of the `JFrame` includes the title bar
and window borders.

The functionality of this applet is limited, but it still shows off
menus, buttons, labels, text fields, applet creation, and two different
kinds of event listeners.

=== Concurrency: GUIs

Stand-alone Java programs have at least one thread, the main thread.
Applets have a similar thread that calls its `init()` and `start()`
methods. Applications with GUIs (including applets) create additional
threads to manage the GUI behind the scenes.

Although a GUI will create several threads, the most important for the
programmer to worry about is called the _event dispatch thread_ (EDT).
This thread handles events like button clicks. When you write your
`actionPerformed()` method, remember that the EDT is the one that will
actually execute the code inside.

If you are writing a complex program, the EDT may interact with many
other threads, and the synchronization issues discussed in
<<ch14-synchronization#ch14-synchronization>> will become important. However, only
the EDT is allowed to change the state of widgets in a GUI. Using other
threads to do so will work some of the time, but it is not thread-safe
and violates the design of Swing.

==== Worker threads

Thread safety is not the most common multi-threaded GUI problem,
however. Unresponsive GUIs can be found on almost every platform, as you
have no doubt experienced. In Java, unresponsive GUIs usually happen
because the programmer is using the event dispatch thread to do some
task that takes too long. Because the EDT is responsible for updating
the GUI, the GUI freezes, and the user has to wait.

This is quite a conundrum. On the one hand, the EDT is the only thread
allowed to update widgets. On the other, it has to do its work quickly
so that the GUI is responsive. The solution is to spawn _worker threads_
to do the job. When they are done, they inform the EDT so that it is
able to update the GUI.

Let's look at a GUI with two `JButton` widgets and two `JLabel` widgets.
When one button is pressed, the EDT goes to sleep for 5 seconds before
displaying an answer on the first label (in this case, approximately
latexmath:[\sqrt{2}]). When the other button is pressed, it increments
a counter and displays the value in the second label.

.GUI that becomes unresponsive when the "`Compute`" button is pressed.
[source, java, linenums]
[[UnresponsiveGUIProgram]]
----
include::{programsdir}/UnresponsiveGUI.java[]
----

[[unresponsiveGUIFigure]]
[.text-center]
.GUI generated by <<UnresponsiveGUIProgram>>.
image::unresponsiveGUIFigure.png[scaledwidth=40%,pdfwidth=40%,width=40%]


If you click the "`Compute`" button, the GUI becomes unresponsive.
Specifically, you cannot click on the "`Increment`" button, but you
should still be able to move the frame around the desktop on most
systems. Furthermore, some thread in the GUI is registering the clicks
you do on the "`Increment`" button, but events triggered by those clicks
are not handled until after the EDT wakes up. At that point, the counter
will shoot up in value unpredictably.

****
<<unresponsiveGUIExercise>> +
<<calculatingGUIExercise>>
****

One solution is to create an anonymous inner class that extends
`SwingWorker`. The `SwingWorker` class is abstract, but it is also
_generic_, meaning that it has type parameters (given in angle brackets)
which specify what type of objects it interacts with. Generic classes
are often containers like `LinkedList` where the type parameter says
what kind of objects will be kept in the list. <<ch18-dynamic-data-structures#ch18-dynamic-data-structures>> covers generics in some depth. The reason we need
generics for `SwingWorker` is so that it can specify what kind of object
it will return when it finishes its work. The first type parameter
specifies the type that the worker will return when it completes its
work. The second specifies the type that the worker will return
periodically in the process of doing work (which can be useful for
updating progress bars). Examine the following program which has added a
`SwingWorker` to its `actionPerformed()` method but is otherwise the
same as <<UnresponsiveGUIProgram>>.

.GUI that uses `SwingWorker` to avoid becoming unresponsive.
[source, java, linenums]
[[WorkerGUIProgram]]
----
include::{programsdir}/WorkerGUI.java[]
----

In this program, the first type parameter for the `SwingWorker` is
`String` because we are going to set the text in a `JLabel` with its
result. The second parameter is `Void`, meaning that we do not intend to
return any values periodically. Most child classes of `SwingWorker`
should override the `doInBackground()` and `done()` methods.

The `doInBackground()` method performs the time-consuming work that we
want done on another thread. In our example, the "`work`" is going to
sleep, but it will generally be some CPU or I/O intensive process.
Afterwards, it returns the answer it found. The `done()` method is
called automatically by the EDT after `doInBackground()` finishes. After
the `SwingWorker` object has been created, the `execute()` method starts
it working. The GUI will look identical to the unresponsive version
(except for the title), but it will remain responsive.

This syntax is not particularly elegant, but it accomplishes a complex
task. It spawns a thread transparently, and then the EDT is given work
when the thread gives back its answer. Using a `SwingWorker` is not
always required, but it is a useful tool to have in your arsenal if you
plan on writing industrial-strength GUIs.

****
<<SwingWorkerExercise>>
****


=== Summary

In this chapter we introduce the basics of constructing a GUI to allow
users to interact with an application. We show how to add widgets such
as buttons and text boxes and use layout managers to organize their
appearance. We show how you can add action listeners and other event
handlers so that user actions can perform useful tasks. Finally, we show
how these techniques can be applied to GUIs on stand-alone applications
as well as applets that run inside of a web browser.

While Java offers a large variety of widgets and listeners, this
introduction is limited to a few of the most commonly used. Once you
understand the basics of GUI construction as described in this chapter,
it should be easy to understand the extensive Java tutorial at the Oracle
http://download.oracle.com/javase/tutorial/uiswing/components[Swing Components tutorial site^] or other
reference sources.

=== Exercises
*Conceptual Problems*

.  In
<<FrameWithPanelAndActionsProgram>>, why have we declared the
buttons and the text box to be `final`?
.  Note that both `ActionListener`
and `MouseListener` interfaces can be used to process button clicks.
Under which circumstances is `ActionListener` better? Under which is
`MouseListener` better?
.  [[MouseAdaptorExercise]] Why is the `MouseAdapter`
abstract class useful?
.  [[JMenuBarExercise]] What do you expect will happen if you
used `setJMenuBar()` to set two different menu bars on a single `JFrame`
object?
.  Describe the situations that the
following event listeners are useful for: `ActionListener`,
`MouseListener`, `ItemListener`, and `KeyListener`

*Programming Practice*

.  Remove the two
instances of the keyword `final` from
<<FrameWithPanelAndActionsProgram>> and try to compile it. Why
does the compiler complain? What do you conclude regarding the use of
`final` with respect to local variables used in the `actionPerformed()`
method of an anonymous inner class? Why is this not a concern for
top-level, named classes used as an `ActionListener`?
.  Write a program that creates a
GUI containing two buttons labeled "`Start`" and "`Done.`" The GUI frame
should be labeled "`Start and Done.`"
.  [[mouseEventsExercise]] Modify
<<SimpleMouseEventsProgram>> by implementing the
`mouseExited()`, `mousePressed()`, and `mouseReleased()` methods. Each
method must display a suitable message in the text box when the
corresponding event occurs. For example, when the mouse exits button
`one`, the text box should display "`Mouse exits One.`"
.  [[iconSoundsExercise]] Modify
<<IconExampleProgram>> such that clicking the icon-decorated
button generates a roaring sound. Note that this will require you to add
an `ActionListener` to the button, create an audio clip for the desired
sound, and then play this click when the button is clicked. Consider
visiting http://www.freesound.org[freesound^] for free sound files.
. [[selfieExercise]] Write a Java program that
creates a GUI containing a label with a picture of yourself.
. [[animalSoundsExercise]] Extend the `SoundGame` class
developed in <<soundGameExample>> to include sounds for
various animals. You may find a variety of publicly available sounds
files for use in your program. The Freesound link above is only one
source.
+
Note that some sites explicitly ask you not to embed the sound file URL
into your program. In those cases, download the sound file into your
local directory and load it from there into your application.
. [[stopPlayingSoundExercise]] In <<soundGameExample>> we stopped both the chirp and the bark sounds because the action
listener corresponding to the "`Stop Playing`" button does not know
which sound is playing. Modify <<SoundGameProgram>> so that
only the sound that is playing is stopped. You may need to declare
another variable to keep track of which is playing.
. [[hoverSoundExercise]] Modify
<<AnimalIdentifierProgram>> so that it plays a sound associated
with an animal when the mouse is clicked over its label. Note that this
is an example of a situation where a `MouseListener` can be used to
listen for mouse click events though an `ActionListener` cannot. As in
<<iconSoundsExercise>> and <<animalSoundsExercise>>, you may need to download sounds from
the Internet.
. Modify the applet from
<<Solution: Math applet>> to display the problem number the user
is working on. The first problem is numbered "`Problem 1`" with
subsequent problems 2, 3, and so on. The number should increase each
time the user hits the Submit button. Find a suitable place on the GUI
to display this information. You may need to add a panel to reorganize
the GUI.
. Remove the `actionPerformed()` and
`itemStateChanged()` methods from the `MathTutorApplet` class given in
<<Solution: Math applet>>. Move the code from these methods into
individual anonymous inner classes added to the `add`, `subtract`,
`multiply`, `divide`, `submit`, and `advanced` objects.
+
Note that you are now able to remove `ActionListener` and `ItemListener`
from the list of implemented interfaces for the `MathTutorApplet` class.
Reorganizing the code this way should have no impact on the
functionality of the applet. Is doing so a good idea or not? Why?
. [[widgetAddingOrderExercise]] In
<<FrameWithPanelAndActionsProgram>> exchange the first two
`add()` method calls on the `soundPanel` so that `bark` is added to the
panel before the `chirp`. Explain how the appearance of the GUI is
changed.
. [[multipleAddsExercise]] Modify
<<FrameWithPanelProgram>> by adding a second panel named
`secondPanel`. Create a new button named `train` with the label
"`Train.`" Add `train` to `secondPanel`. Now add `secondPanel` to
`soundCheck` and look at the GUI generated. Can you explain why only one
panel is visible?
. [[resizingGUIExercise]] Remove the line `frame.setResizable(false);` from <<FlowLayoutExampleProgram>>. Run the modified program and
resize the frame to various sizes. How does the placement of the buttons
change?
. [[packedGUIExercise]] Modify
<<FlowLayoutExampleProgram>> by deleting the lines that set the
frame size. What does the resulting GUI look like? Now add the following
code just before the line `frame.setResizable(false);`:
+
[source,java]
----
demo.pack();
----
+
When you run the modified program, what is the impact of using the
`pack()` method?
. [[GridLayoutExercise]] Create a GUI with a frame that uses
`GridLayout` and has a suitable size. Use a 3 × 2
layout with a horizontal and vertical spacing of 5 pixels each. Use a
loop to add eight buttons to your frame, labeled 1 through 8. Observe
how the frame expands to include all the buttons even though the
initially specified `GridLayout` had only 6 cells. Depending on the
frame size, you might have to resize the window to see all cells and
buttons. What happens if you add fewer than 6?
. [[addMenuBarExercise]] Write a Java program that creates
a GUI with a frame and a menu bar containing a single menu. Add a menu
item to this menu. Use the `add()` method, not the `setJMenuBar()`
method, to add the menu bar to the frame. What is the difference between
using the `add()` method and the `setJMenuBar()` method to add a menu
bar to a `JFrame`?
. [[appletExercise]] Use the example from the book to
create a suitable HTML file that embeds the `RainbowApplet` class from
<<rainbowAppletExample>> and links to the Java source code. Now
upload the class file, the source code, and the HTML file to a web
server so that you can run the applet over the Internet. Have a friend
test out your code on a computer in another location to make sure that
it works.

*Experiments*

. [[unresponsiveGUIExercise]] Recall that
<<UnresponsiveGUIProgram>> is unresponsive because the event
dispatch thread goes to sleep for 5 seconds (5,000 milliseconds). Experiment with this value to determine
what is a reasonable amount of time for the EDT to be blocked before the
GUI feels unresponsive.
. [[calculatingGUIExercise]] <<UnresponsiveGUIProgram>> is
unrealistic because the EDT simply goes to sleep. Normally, a GUI
becomes unresponsive because the EDT is performing extensive
calculations or doing slow I/O operations. Replace the line that sleeps with a short loop that performs significant calculations. One
simple way to spend a lot of computational time is by summing the sines
of random numbers, similar to the work done in <<arraySummationExample>>. How many sines do you need to compute to make the GUI
unresponsive for 5 seconds?
. [[SwingWorkerExercise]] Take the computationally expensive loop
from <<calculatingGUIExercise>> and use it to replace
the line that sleeps in <<WorkerGUIProgram>>, the
`SwingWorker` version of the program. Does the program become
unresponsive if you run it? If possible, run the program on Windows,
Mac, and Linux environments. If it is unresponsive in some environments
but not others, why do you think that might be?
