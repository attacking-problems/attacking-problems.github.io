[#ch21-network-communication]
:imagesdir: chapters/21-network-communication/images
:programsdir: chapters/21-network-communication/programs
== Network Communication

[quote, Neal Stephenson]
____
Arguing with anonymous strangers on the Internet is a sucker's game because they almost always
turn out to be--or to be indistinguishable from--self-righteous sixteen-year-olds possessing
infinite amounts of free time.
____

=== Problem: Web server

It is no accident that the previous chapter about file I/O is followed
by this one about networking. At first glance, the two probably seem
unrelated. As it happens, both files and networks are used for input and
output, and the designers of Java were careful to create an API with a
similar interface for both.

In the next two sections, we discuss how this API works, but first we
introduce the problem: You need to create a web server application. The
term _server_ is used to describe a computer on a network which other
computers, called _clients_, connect to in order to access some services
or resources. When you surf the Internet, your computer is a client
connecting to web servers all over the world. Writing a web server might
seem like a daunting task. The web browser you run on your client
computer (e.g. Chrome, Firefox, Internet Explorer, or Safari) is, in modern
times, a very complicated program, capable of playing sounds and movies,
browsing in multiple tabs, automatically encrypting and decrypting
secure information, and, at the very least, correctly displaying web
pages of every description.

In contrast, a web server application is much simpler. At its heart, a
web server application gets requests for files and sends those files
over the network. More advanced servers can execute code and dynamically
generate pages, and many web servers are multi-threaded to support heavy
traffic. The web server you are writing needs only to focus on getting
requests for files and sending those files back to the requester.

==== HTTP requests

To receive requests, a web server uses something called _hypertext
transfer protocol (HTTP)_, which is just a way of specifying the format
of the requests. The only request we are interested in is the `GET`
request. All `GET` requests have the following format. +
`GET` *path* `HTTP/`**version** +
where *path* is the path of the file being requested and *version* is
the HTTP version number. A typical request might be as follows. +
`GET /images/banner.jpg HTTP/1.1` +
You should also note that all HTTP commands end with *two* newline
characters (`'\\n'`). The extra blank line makes it easier to separate
the commands from other data being sent.

==== HTTP responses

After your web server receives a `GET` message, it looks for the file
specified by the *path*. If the server finds the file, it sends the
following message. +
`HTTP/1.1 200 OK` +
Again, note that this message is followed with two newline characters.
After this message is sent, the server sends the requested file, byte by
byte across the network. If the file cannot be found by the web server,
it sends an error message as follows. +
`HTTP/1.1 404 Not Found` +
Of course, two newlines will be sent after this as well. After the error
message, servers will also typically send some default web page with an
explanation in HTML.

Now, we return to the more fundamental problem of how to communicate
over a network.

=== Concepts: TCP/IP communication

We begin where nearly every discussion of computer networking begins,
with the Open Systems Interconnection Basic Reference Model (or OSI
model). As we mentioned before, the designers of Java wanted to make a
networking API which was very similar to the file system API. This
single API must be used for JVM's running on Windows or on MacÂ OS or on
Linux or any other operating system. Even with the same operating
system, different computers have different hardware. Some computers have
wired connections to a router or gateway. Others are connected
wirelessly. And somehow, you have to figure out the address of the
computer you want to send messages to and deal with its network,
hardware, and software.

There are so many steps in the process that it seems hopelessly
complicated. To combat this problem, the OSI seven layer model was
developed. Each layer defines a specification for one aspect of the
communication path between two computers. As long as a particular layer
interacts smoothly with the one above it and below it, that layer could
take the form of many different hardware or software choices. Listing
them in order from the highest level (closest to the user) to the lowest
level (closest to the hardware), the layers are as follows.

* Layer 7: Application Layer
* Layer 6: Presentation Layer
* Layer 5: Session Layer
* Layer 4: Transport Layer
* Layer 3: Network Layer
* Layer 2: Data Link Layer
* Layer 1: Physical Layer

The application layer is where your code is. The Java networking API
calls that your code uses to send and receive data comprise the
application layer for your purposes. The only thing above this layer is
the user. Protocols like HTTP and FTP are the province of this layer.
All the other communication problems have been solved, and the key issue
is what to do with the data that is communicated.

The presentation layer changes one kind of message encoding to another.
This layer is not one people usually spend a lot of time worrying about,
but some kinds of encryption and compression can happen here.

The session layer allows for the creation of sessions when communicating
between computers. Sessions requiring authentication and permissions can
be dealt with here, but,in practice, this layer is not often used. One
notable exception is the Secure Sockets Layer (SSL), the technology most
commonly used to protect passwords and credit card numbers when you make
online purchases.

The transport layer is concerned with the making the lower level
communication of data more transparent to higher layers. This layer
typically breaks larger messages into smaller packets of data which can
be sent across the network. This layer can also provide reliability by
checking to see if these packets make it to their destinations and
resending them otherwise. The two most important protocols for this
layer are Transmission Control Protocol (TCP) and User Datagram Protocol
(UDP). TCP is more commonly used and provides communication that is
reliable and ensures that packets are delivered in order. TCP is used
for file transfers, e-mail, web browsing, and any number of other web
applications. UDP does not have guarantees about reliability or
ordering; however, UDP is faster. For this reason, UDP is used for
streaming media and online games.

The network layer is responsible for packet transmission from source to
destination. It is concerned with addressing schemes and routing. The
most well-known example of a network layer protocol is the Internet
Protocol (IP) used to make the Internet work.

If the network layer worries about sending of packets from source to
destination, the data link layer is responsible for the actual
transmission of packets between each link in the chain. Here hardware
becomes more important because there are so many different kinds of
networks. Examples of data link layers include Ethernet, token ring
networks, IEEE 802.11 wireless networks, and many more.

Finally, the lowest level is the physical layer. This layer defines the
actual physical specifications for sending raw information from one
place to another, over a wire or wirelessly. This layer is typically the
least interesting to programmers but is a key area for electrical
engineers.

=== Syntax: Networking in Java

The seven layer model might seem overwhelming, but there are only a few
key pieces that we'll need on a regular basis. In fact, the system of
layers is designed to help people focus on the one or two layers
specified to their needs and ignore the rest.

==== Addresses

The first topic we touch on is the network layer. What we need from this
layer are addresses. A network address is much like a street address. It
gives the location on the network of a computer so that messages can be
sent there.

For most systems you use, such an address is be an _IP address_. There
are two current versions of IP addresses, IPv4 and IPv6. IPv6 is the way
of the future and provides a huge number of possible addresses. Not all
systems support IPv6, and the general public is not very aware of it.
Although it will one day be the standard, we use the more common IPv4
addresses here. An IPv4 address is typically written as four decimal
numbers separated by dots. Each of these four numbers is in the range 0
- 255. For example, `64.233.187.99` and `192.168.1.1` are IPv4
addresses.

==== Sockets

The second topic we focus on is the transport layer. Here, you need to
make a choice between TCP or UDP for communication. In this book, we
only cover TCP communication because it is reliable and much more
commonly used than UDP. If you need to use UDP communication, the basics
are not too different from TCP, and there are many excellent resources
online.

To create a TCP connection, you typically need a server program and a
client program. The difference between the two is not necessarily big.
In fact, both the client and the server could be running on the same
computer. What distinguishes the server is that it sets up a _port_ and
listens to it, waiting for a connection. Once the client makes a
connection, the two programs can send and receive data on an equal
footing.

We just mentioned the term port. As you know, an address is the location
of a computer in a network, but a single computer may be performing many
different kinds of network communications. For example, your computer
could be running a web browser, an instant message application, an
online game, and a number of other things. So that none of these
programs become confused and get each others' messages, each program
uses a separate port for communication. To the outside world, your
computer usually only has a single address but thousands of available
ports. Many of these ports are set aside for specific purposes. For
example, port 20 is for FTP, port 23 is for Telnet, and port 80 is for
HTTP (webpages).

When you write a server program, you will usually create a
`ServerSocket` object which is linked to a particular port. For example,
if you wanted to write a web server, you might create a `ServerSocket`
as follows.

[source, java]
----
ServerSocket serverSocket = new ServerSocket( 80 );
----

Once the `ServerSocket` object has been created, the server will
typically listen to the socket and try to accept incoming connections.
When a connection is accepted, a new `Socket` object is created for that
connection. The purpose of the `ServerSocket` is just to set up this
`Socket`. The `ServerSocket` doesn't do any real communication on its
own. This system may seem indirect, but it allows for greater
flexibility. For example, a server could have a thread just listening
for connections. When a connection is made, it could spawn a new thread
to do the communication. Commercial web servers often function in this
way. The code for a server to listen for a connection is:

[source, java]
----
Socket socket = serverSocket.accept();
----

The `accept()` method is a blocking method; thus, the server will wait
for a connection before doing anything else.

Now, if you want to write the client which connects to such a server,
you can create the `Socket` object directly.

[source, java]
----
Socket socket = new Socket( "64.233.187.99", 80 );
----

The first parameter is a `String` specifying the address of the server,
either as an IP address as shown or as domain like `"google.com"`. The
second parameter is, of course, the port you want to connect on.

==== Receiving and sending data

From here on out, we no longer have to worry about the differences
between the client and server. Both programs have a `Socket` object that
can be used for communication.

In order to get input from a `Socket`, you first call its
`getInputStream()` method. You can use the `InputStream` returned to
create an object used for normal file input like in the first half of
the chapter. The considerations are similar. If you only need to receive
plain, human readable from the `Socket`, you can create a `Scanner`
object as follows.

[source, java]
----
Scanner in = new Scanner( socket.getInputStream() );
----

Over the network, it will be much more common to send files and other
binary data. For that purpose you can create an `ObjectInputStream` or
`DataInput\-Stream` from the `Socket` in much the same way.

[source, java]
----
ObjectInputStream in = new ObjectInputStream( socket.getInputStream() );
----

It should be unsurprising that output is just as easy as input. Text
output can be accomplished by creating a `PrintWriter`.

[source, java]
----
PrintWriter out = new PrintWriter( socket.getOutputStream() );
----

Likewise, binary output can be accomplished by creating an
`ObjectOutputStream` or a `DataOutputStream`.

[source, java]
----
ObjectOutputStream out = new ObjectOutputStream(
    socket.getOutputStream() );
----

Once you have these input and output objects, you use them in the same
way you would for file processing. There are a few minor differences to
keep in mind. In the first place, when reading data, you may not know
when more is coming. There is no explicit end of file. Also, it is
sometimes necessary to call a `flush()` method after doing a write.
Unlike writing to a disk, a socket may wait for a sizable chunk of data
to be accumulated before it gets sent across the network. Without a
`flush()`, the data you write may not be sent immediately.

.Simple client and server
====

Here's an example of a piece of server code which listens on port 4321
waits for a connection, then reads 100 `int` values in binary form from
the socket, and prints their sum.

[source, java]
----
try{
    ServerSocket serverSocket = new ServerSocket( 4321 );
    Socket socket = serverSocket.accept();
    ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
    int sum = 0;
    for( int i = 0; i < 100; i++ )
        sum += in.readInt();
    in.close();
    System.out.println("Sum: " + sum);
}
catch( IOException e )
{}
----

Now, here's a companion piece of client code which connects to port 4321
and sends 100 `int` values in binary form, specifically, the first 100
perfect squares.

[source, java]
----
try{
    Socket socket = new Socket( "127.0.0.1", 4321 );
    ObjectOutputStream out = new ObjectOutputStream(
        socket.getOutputStream());
    for( int i = 1; i <= 100; i++ )
        out.writeInt(i*i);
    out.close();
}
catch( IOException e )
{}
----

Note that this client code connects to the IP address `127.0.0.1`. This
is a special loopback IP address. When you connect to this IP address,
it connects to the machine you are currently working on. In this way,
you can test your networking code without needing two separate
computers. To test this client and server code together, you you will
need to run two virtual machines. The simplest way to do this is open
two command line prompts and run the client from one and the server from
the other. Be sure that you start the server first so that the client
has something to connect to.

====

[[chatClientAndServerExample]]
.Chat client and server
====
Now we look at a more complicated example of network communication which
should be familiar: a chat program. If you want to apply the GUI design
from <<Constructing Graphical User Interfaces>>, you can
make a windowed version of this chat program which looks more like chat
programs you are used to. For now, our chat program is be text only.

****
<<exercise21.9, Exercise 21.9>>
****

The functionality of the program is simple. Once connected to a single
other chat program, the user will enter his or her name, then enter
lines of text each followed by a newline. The program will insert the
user's name at the beginning of each line of text and then send it
across the network to the other chat program, which will display it. We
encapsulate both client and server functionality in a class called
`Chat`.

The first step is the appropriate import statements and the `main()`
method, which creates a client or a server `Chat` object, depending on
command line parameters.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=1..14]
----


The code given here calls the server version of the `Chat` constructor
if the argument `"-s"` is given and the client version of the `Chat`
constructor if the argument `"-c"` is given. For the server, only a port
is required, but the client also needs an IP address to connect to.

The server `Chat` constructor takes the port and listens for a
connection on it. After a connection, it calls the `runChat()` method to
perform the actual business of sending and receiving chats.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=16..24]
----


The client constructor is similar but connects directly to the specified
IP address on the specified port.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=26..34]
----


Once the client and server are connected, they both run the `runChat()`
method, which creates a new `Sender` and a new `Receiver` to do the
sending and receiving. Note that both `start()` and `join()` are called
on the `Sender` and `Receiver` objects. These calls are needed because
both classes are subclasses of `Thread`. Sending messages is an
independent task concerned with reading input from the keyboard and then
sending it across the network. Receiving messages is also an independent
task, but it is concerned with reading input from the network and
printing it on the screen. Since both tasks are independent, it is
reasonable to allocate a separate thread to each.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=36..43]
----


Below is the private inner class `Sender`. In this case it is convenient
but not necessary to make `Sender` an inner class, especially since it
is so short. The only piece of data `Sender` shares with `Chat` is the
all important `socket` variable. The `Sender` begins by creating a
`PrintWriter` object from the `Socket` output stream. After reading a
name from the user, it waits for a line from the user. Each time a line
is ready, it is printed and flushed, with the user name inserted at the
beginning, through the `PrintWriter` connected to the `Socket` output
stream. When the user types `quit`, the `Socket` will be closed.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=45..69]
----

Below is the private inner class `Receiver`, the counterpart of
`Sender`, as well as the last thing defined in the `Chat` class. The
`Receiver` class is even simpler than the `Sender` class. After creating
a `Scanner` object connected to the input stream of the `Socket`, it
waits for a line of text to arrive from the connection. Each time a line
arrives, it prints it to the screen. Here again, you can see that this
problem is solved with threads much more easily than without them. Both
the `in.hasNextLine()` method called by `Sender` and the
`netIn.hasNextLine()` method called by `Receiver` are blocking
functions. Because each might wait for input before continuing, they
cannot easily be combined in one thread of execution.

[source, java, linenums]
----
include::{programsdir}/Chat.java[lines=71..83]
----

Although the fundamentals are present in this example, a real chat
client should provide a buddy list, the opportunity to talk to more than
one other user at a time, real error-handling code in the
`catch`-blocks, and many other features. Some of these features are
easier to provide in a GUI.

====

In the next section, we give a solution for the Web Server problem.
Since only the server side is provided, some of the networking is
simpler, and there are no threads. However, the communication is done in
both binary and text mode.

=== Solution: Web server

Here is our solution to the Web Server problem. As usual, our solution
doesn't provide all the error checking or features that a real web
server would, but it is entirely functional. When you compile and run
the code, it will start a web server on port 8080 (an alternative port
for HTTP) in the directory you run it from. Feel free to change those
settings in the `main()` method. When the server is running, you should
be able to open any web browser and go to `http://127.0.0.1`. If you put
some sample HTML files in the directory you run the server from, you
should be able to browse them.

As for our code, we start with the imports and constructor below. Note
that the server has fields for the port communication will take place
on, the root directory for the web page, and a `ServerSocket`. The
`main()` method does nothing but call the constructor using the current
directory as an argument and then start the server.

[source, java, linenums]
----
include::{programsdir}/WebServer.java[lines=1..23]
----


Below is the `start()` method. This method contains the central loop of
the web server that waits for connections and loops forever. Once a
connection has been made, the server creates input and output objects
from the socket connection. Then, it tries to serve requests coming from
the socket input. Our web server ignores any request other than a `GET`
request and closes the connection after the first `GET`. When a `GET`
request is made, the server removes the `"HTTP"` at the beginning and
passes off the remaining path to the `serve()` method. Everything else
in the `start()` method is made up of the necessary exception handling
machinery.

Note that the `out` object is of type `ObjectOutputStream`, allowing us
to send binary data over the socket. However, the `in` variable is of
type `Scanner`, because HTTP requests are generally only text.

[source, java, linenums]
----
include::{programsdir}/WebServer.java[lines=25..63]
----


Next is a short utility method which provides some amount of platform
independence. The `getPath()` method take in a `String` representation
of a path requested by a web browser and format it. This path should
always be given in the Unix or Linux style with slashes (`/`) separating
each directory. To function smoothly with other operating systems,
`getPath()` uses the class variable `File.separatorChar` which gives the
`char` used to separate directories on whichever platform the JVM is
currently running. In addition, `getPath()` adds `"index.html"` to the
end of the path if the path ends with a directory rather than a file
name. Real web servers try a list of many different files such as
`index.html`, `index.htm`, `index.php`, and so on, until a file is found
or the list runs out.

[source, java, linenums]
----
include::{programsdir}/WebServer.java[lines=65..72]
----


The last method in the `WebServer` class takes in a path and sends the
corresponding file over the nextwork. The `serve()` method first tries
to find the specified file. If it fails, it sends an `HTTP 404` message
with a short explanatory piece of HTML. Anyone who surfs the Internet
should be familiar with 404 messages. On the other hand, if this method
finds the file, it sends the `HTTP 200` method indicating success and
then creates a new `ObjectInputStream` object to read the file in binary
format. In this case, it is necessary to read the file in binary. In
general, HTML files are simple text files which are human readable, but
the image files that web servers must often send such as GIF and JPEG
files are binary files which are filled with unprintable characters.
Because we need to send binary data, we were also careful to open an
`ObjectOutputStream` on the socket earlier.

Once the file is open, the `serve()` method simply reads it in, byte by
byte, and sends each byte out over the socket. After the file has been
sent, the method closes it and returns.

[source, java, linenums]
----
include::{programsdir}/WebServer.java[lines=74..104]
----


Because a web server is a real world application, we have to give the
usual caveat that this implementation is quite bare-bones. There are
other HTTP requests and many features, including error handling, that a
web server should do better. Feel free to extend the functionality.

Also, you might notice that there is no way to stop the web server. It
has an infinite loop which is only broken if there is an `IOException`
thrown. From a Windows, Linux, or Mac command prompt, you can usually
stop a running program by typing `Ctrl-C`.

=== Concurrency: Networking

Throughout this book, we have used concurrency primarily for the purpose
of speedup. For that kind of performance improvement, concurrency is
essentially icing on the cake. Unless you are performing massively
parallel computations such as code breaking or scientific computing,
concurrency will probably make your application run just a little faster
or a little smoother.

With network programming, the situation is different. Many networked
programs, including chat clients, web servers, and peer-to-peer file
sharing software, will simultaneously be connected to tens if not
hundreds of other computers at the same time. While there are
single-threaded strategies to handle these scenarios, it is natural to
handle them in a multi-threaded way.

A web server at Google, for example, may service thousands of requests
per second. If each request had to wait for the previous one to come to
completion, the server would become hopelessly bogged down. By using a
single thread to listen to requests and then spawn worker threads as
needed, the server can run more smoothly.

****
<<exercise21.10, Exercise 21.10>> +
<<exercise21.11, Exercise 21.11>>
****

Even in <<chatClientAndServerExample>>, it was convenient to
create two different threads, `Sender` and `Receiver`. We did not create
them for speedup but simply because they were doing two different jobs.
Since the `Sender` waits for the user to type a line and the `Receiver`
waits for a line of text to arrive over the network, it would be
difficult to write a single thread that could handle both jobs. Both
threads call the `hasNextLine()` method, which can block execution. A
single thread waiting to see if the user had entered more text could not
respond to text arriving over the network until the user hit enter.

We only touch briefly on networking in this book. As the Internet
evolves, standards and APIs evolve as well. Some libraries can create
and manage threads transparently, without the user worrying about the
details. In other cases, your program must explicitly use multiple
threads to solve the networking problem effectively.

=== Exercises
*Conceptual Problems*

1. [[exercise21.1]] Why are there so many similarities between the network I/O and the
file I/O APIs in Java?
2. [[exercise21.2]] Explain the difference between client and server computers in
network communication. Is it possible for a single computer to be both a
client and a server?
3. [[exercise21.3]] Why is writing a web browser so much more complicated than writing a
web server?
4. [[exercise21.4]] Name and briefly describe the seven layers of the OSI model.
5. [[exercise21.5]] Modern computers often have many programs running that are all in
communication over a network. Since a computer often has only one IP
address that the outside world can send to, how are messages that arrive
at the computer connected to the right program?
6. [[exercise21.6]] What are the most popular choices of protocols at the transport
layer of the OSI model? What are the advantages and disadvantages of
each?
7. [[exercise21.7]] How many possible IP addresses are there in IPv4? IPv6 addresses are
often written as eight groups of four hexadecimal digits, totaling 32
hexadecimal digits. How many possible IP addresses are there in IPv6?
+
*Programming Practice*
8. [[exercise21.8]] Recall the client and server from <<Receiving and sending data>> that, respectively, send 100 `int` values and sum them.
Rewrite these fragments to send and receive the `int` values in text
rather than binary format.
9.  [[exercise21.9]] Add a GUI based on `JFrame` for the chat
program given in <<chatClientAndServerExample>>. Use a
(non-editable) `JTextArea` to display the log of messages, including
user name. Provide a `JTextField` for entering messages, a `JButton` for
sending messages, and another `JButton` for closing the network
connections and ending the program.
10. [[exercise21.10]] Study the web server
implementation from <<Solution: Web server>>. Implement a similar
web server which is multi-threaded. Instead of serving each request with
the same thread that is listening for connections, spawn a new thread to
handle the request each time a connection is made.
11. [[exercise21.11]] One of the weaknesses of the web
server from the previous exercise is that a new thread has to be created
for each connection. An alternative approach is to create a pool of
threads to handle requests. Then, when a new request arrives, an idle
thread is selected from the pool. Extend the solution to the previous
exercise to use a fixed pool of 10 worker threads.
+
*Experiments*
12. [[exercise21.12]] Consider the multi-threaded implementation of a web server from
<<exercise21.10, Exercise 21.10>>. Can you design an
experiment to measure the average amount of time a client waits to
receive the requested file? How does this time change from the single
threaded to the multi-threaded version? If the file size is larger, is
the increase in the waiting time the same in both the single and
multi-threaded versions?
